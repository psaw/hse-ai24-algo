# import os
# import sys

# path = os.path.dirname(os.path.abspath(__file__))
# sys.stdin = open(path + "/input1.txt", "r")


def solve(n: int) -> int:
    """При переработке радиоактивных материалов образуются отходы трех видов:
    - особо опасные (тип A),
    - неопасные (тип B)
    - совсем не опасные (тип C).

    Для их хранения используются одинаковые контейнеры.
    После помещения отходов в контейнеры последние укладываются вертикальной стопкой.
    Стопка считается взрывоопасной, если в ней подряд идет более одного контейнера типа A.
    Стопка считается безопасной, если она не является взрывоопасной.

    Для заданного количества контейнеров N определить число безопасных стопок.

    ### Решение:
    da[] - количество взрывоопасных стопок длины i, оканчивающихся на A
    db[] - количество взрывоопасных стопок длины i, оканчивающихся на B
    dc - не отслеживаем, т.к. оно равно db. Где нужно dc - умножим db на 2.

    da[i] = 3**(i-2) + 2*db[i-1],
    где
    - 3**(i-2) - число всех стопок, оканчивающихся на A, на шаге i-1,
      что так же равно числу всех возможных стопок на шаге i-2, т.к. к ним добавится A.
      Добавление еще одной A к любой такой стопке делает ее опасной.
    - db[i-1]  - число опасных стопок, оканчивающихся на B (или C), на шаге i-1,
      Добавление А к любой такой не меняет количество опасных.

    db[i] = da[i-1] + 2*db[i-1],
    Добавление B (или C) не меняет кол-во опасных. Т.о. все опасные стопки с шага i-1

    """
    da = [0] * (n + 1)
    db = [0] * (n + 1)
    da[0] = da[1] = 0
    db[0] = db[1] = 0

    for i in range(2, n + 1):
        da[i] = 3 ** (i - 2) + 2 * db[i - 1]
        db[i] = da[i - 1] + 2 * db[i - 1]

    return 3**n - da[n] - 2 * db[n]


N = int(input())
print(solve(N))
