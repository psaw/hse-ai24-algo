import time
import os
import sys
import math

path = os.path.dirname(os.path.abspath(__file__))
sys.stdin = open(path + "/input.txt", "r")

"""Неисправный марсоход"""
A = int(input())
B = int(input())
C = int(input())


# too slow
def solve1(A: int, B: int, C: int) -> int:
    # переменные для хранения мин. числа сигналов...
    # это имитация движения окна по массиву
    c = 0  # ... для получения уровня bat
    c_1 = 0  # ... для получения уровня bat-1
    c_2 = 0  # ... для получения уровня bat-2

    # повышаем заряд до целевого и считаем необходимые сигналы
    for bat in range(A + 1, B + 1):
        c_2, c_1 = c_1, c  # сдвигаем "окно"
        if bat % C == 0:
            c = 0  # если кратно C, то 0 сигналов (невозможно)
        else:
            c = min(
                (c_1 + 1) if (bat - 1) % C else math.inf,  # если бы послали X
                (c_2 + 1) if (bat - 2) % C else math.inf,  # если бы послали Y
            )
        # print(f"bat: {bat}, c: {c}")

    return c


def solve2(A: int, B: int, C: int) -> int | float:
    # переменные для хранения мин. числа сигналов...
    # это имитация движения окна по массиву
    c = 0  # ... для получения уровня bat
    c_1 = 0  # ... для получения уровня bat-1
    c_2 = 0  # ... для получения уровня bat-2

    # повышаем заряд до целевого и считаем необходимые сигналы
    start_time = time.time()
    for bat in range(A + 1, B + 1):
        c_2, c_1 = c_1, c  # сдвигаем "окно"
        if bat % C == 0:
            c = 0  # если кратно C, то 0 сигналов (невозможно)
        elif (bat - 1) % C == 0:
            c = c_2 + 1
        elif (bat - 2) % C == 0:
            c = c_1 + 1
        else:
            c = min(c_1, c_2) + 1

        # print(f"bat: {bat}, c: {c}")
    end_time = time.time()
    print(f"Loop execution time: {end_time - start_time} seconds")
    return c


def solve3(A, B, C):
    # Вывод аналитического решения:
    # 1. при переборе bat повторяются блоки кратные C
    # 2. для перехода через кратное С в следующий блок
    #    всегда нужен 1 сигнал Y (+2)
    # 3. Сколько блоков?
    # 4. Сколько сигналов в одном блоке?
    # 5. Сколько стоит дойти до первого кратного C?
    # 6. Сколько стоит пройти от последнего кратного C до B?
    # Тогда решение:
    # дойти до первого кратного + 1 переход +
    # + число_блоков * (цена_блока + 1 (переход в следующий блок)) +
    # + проход до B (последний неполный блок)

    # Если между A и B нет кратных C, то решение очевидно:
    if (B - A) < C:
        return (B - A) // 2 + (B - A) % 2

    # Сколько стоит дойти до первого кратного C?
    b1 = C - A % C - 1  # осталось от A до "кратного C"-1
    c1 = b1 // 2 + b1 % 2  # сколько сигналов нужно

    # Сколько стоит пройти от последнего "кратного C"+1 до B?
    b2 = B - B % C + 1  # стартовая позиция в неполном блоке
    c2 = (B - b2) // 2 + (B - b2) % 2  # сколько сигналов нужно

    # Сколько полных блоков между первым неполным блоком и последним?
    b3 = ((b2 - 1) - (A + b1 + 1)) // C
    c_C = (C - 2) // 2 + (C - 2) % 2  # цена прохода 1 блока
    c3 = c_C * b3 + b3 - 1  # цена прохода b3 блоков + переходы

    # Суммарная стоимость
    c = c1 + 1 + c2 + 1 + c3
    print(f"{A=}, {B=}, {C=}")
    print(f"{b1=}, {c1=}, {b2=}, {c2=}, {b3=}, {c_C=}, {c3=}")

    # Пример для A,B,C = 1,14,4:
    # 1 2 3   4 5 6 7 8 9 10 11 12 13 14
    # A   b1  *       *         *  b2 B  C=4

    return c


print(solve3(A, B, C))

assert solve3(4, 10, 3) == 4
assert solve3(2, 7, 3) == 3
assert solve3(4, 7, 15) == 2
assert solve3(1, 999_999_999, 2) == 499_999_999
assert solve3(13, 14, 10) == 1
assert solve3(1, 7, 2) == 3
