import os
import sys

path = os.path.dirname(os.path.abspath(__file__))
sys.stdin = open(path + "/input.txt", "r")

"""Прямоугольники"""
N, M = map(int, input().split())
matrix = []
for i in range(N):
    row = list(map(int, input().split()))
    matrix.append(row)


# BUG: решение верное, но слишком медленно
def solve(n: int, m: int, grid: list[list[int]]) -> int:
    """Решение:
    Идея - динамическое программирование с перебором по битовым маскам,
    где каждая битовая маска представляет собой набор клеток, которые
    должны быть накрыты прямоугольниками.

    1. Собрать массив `valid_cells` из доступных клеток матрицы (те, где 0).
    2. Выделить массив `dp` длины `1<<len(valid_cells)` для двоичных масок.
       - Индекс в `dp` - это двоичная маска, разрядности `len(valid_cells)`,
         в которой номер бита - это индекс в `valid_cells`.
       - Значение `dp[i]` - мин. кол-во прямоугольников, которые накрывают все клетки в маске `i`.
    3. Сгенерировать массив `rectangles` всех доступных прямоугольников с учетом вырезанных клеток.
    4. Динамическим программированием заполнить массив `dp`.
    5. Вернуть значение `dp[-1]` (маска `111..111`) -
       мин. кол-во прямоугольников, которые накрывают все клетки.

    Args:
        n (int): число строк
        m (int): число столбцов
        grid (list[int]): матрица размера n x m

    Returns:
        int: минимальное кол-во прямоугольников, которые накрывают все клетки
    """
    # Собрать массив из доступных клеток матрицы
    valid_cells = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 0:
                valid_cells.append((i, j))

    if not valid_cells:
        return 0

    # Общее кол-во доступных клеток (не вырезанных)
    total_cells = len(valid_cells)
    # Все двоичные маски длины total_cells бит
    dp = [float("inf")] * (1 << total_cells)
    # Стартовая маска `000..000`` - пустой набор, требует 0 прямоугольников
    dp[0] = 0

    # Сгенерируем все доступные прямоугольнии (перебор пар координат)
    rectangles = []
    for i1 in range(n):
        for j1 in range(m):
            for i2 in range(i1, n):
                for j2 in range(j1, m):
                    # Для данной пары проверить, что накрывает только доступные клетки
                    valid = True
                    mask = 0
                    for i in range(i1, i2 + 1):
                        for j in range(j1, j2 + 1):
                            if grid[i][j] == 1:  # Вырезанная клетка - ранний выход
                                valid = False
                                break
                            # Для нормальной клетки найдем ее индекс в valid_cells
                            for idx, (ii, jj) in enumerate(valid_cells):
                                if ii == i and jj == j:
                                    mask |= 1 << idx  # .. и включим ее бит в маске
                                    break
                        if not valid:
                            break
                    # Если все клетки прямоугольника накрывают доступные клетки,
                    # то добавим итоговую маску в rectangles
                    if valid and mask > 0:
                        rectangles.append(mask)

    # Динамическое программирование.
    # Для каждой возможной маски добавляем поочередно все валидные прямоугольники.
    # Смотрим какая получится новая маска и говорим что:
    # - либо ее уже видели и есть значение
    # - либо для нее нужно на 1 прямоугольник больше, чем для исходной маски
    # Берем минимум из этих значений.
    #
    # Перебор идет по возрастанию масок, а добавляются в том числе все
    # валидные "единичные" (1 клетка) прямоугольники, поэтому при переходе
    # к следующей маске в цикле гарантированно увидим непустое значение.
    for mask in range(1 << total_cells):
        # добавляем все валидные прямоугольники ..
        for rect_mask in rectangles:
            if (mask & rect_mask) == 0:  # .. но только непересекающиеся
                new_mask = mask | rect_mask  # объединяем маски
                dp[new_mask] = min(
                    dp[new_mask],  # если такое покрытие уже было, то тут не `inf`
                    dp[mask] + 1,  # +1 за счет добавленного прямоугольника
                )
    # Выводим последнее значение массива,
    # т.е. значение для маски `111..111`, т.е. покрытие всех клеток
    return int(dp[-1])


print(solve(N, M, matrix))
